{"ast":null,"code":"var _jsxFileName = \"G:\\\\projects\\\\fortress\\\\node_modules\\\\react-native-tab-view\\\\src\\\\TabViewPagerPan.js\";\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport * as React from 'react';\nimport PropTypes from 'prop-types';\nimport Animated from \"react-native-web/dist/exports/Animated\";\nimport PanResponder from \"react-native-web/dist/exports/PanResponder\";\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport View from \"react-native-web/dist/exports/View\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport { PagerRendererPropType } from \"./TabViewPropTypes\";\nvar DEAD_ZONE = 12;\nvar DefaultTransitionSpec = {\n  timing: Animated.spring,\n  tension: 300,\n  friction: 35\n};\nexport default class TabViewPagerPan extends React.Component {\n  constructor(props) {\n    var _this;\n\n    super(props);\n    _this = this;\n\n    this._isMovingHorizontally = (evt, gestureState) => {\n      return Math.abs(gestureState.dx) > Math.abs(gestureState.dy * 2) && Math.abs(gestureState.vx) > Math.abs(gestureState.vy * 2);\n    };\n\n    this._canMoveScreen = (evt, gestureState) => {\n      if (this.props.swipeEnabled === false) {\n        return false;\n      }\n\n      var {\n        navigationState: {\n          routes\n        }\n      } = this.props;\n      return this._isMovingHorizontally(evt, gestureState) && (gestureState.dx >= DEAD_ZONE && this._currentIndex > 0 || gestureState.dx <= -DEAD_ZONE && this._currentIndex < routes.length - 1);\n    };\n\n    this._startGesture = () => {\n      this.props.onSwipeStart && this.props.onSwipeStart();\n      this.props.panX.stopAnimation();\n    };\n\n    this._respondToGesture = (evt, gestureState) => {\n      var {\n        navigationState: {\n          routes,\n          index\n        }\n      } = this.props;\n\n      if (gestureState.dx > 0 && index <= 0 || gestureState.dx < 0 && index >= routes.length - 1) {\n        return;\n      }\n\n      this.props.panX.setValue(gestureState.dx);\n    };\n\n    this._finishGesture = (evt, gestureState) => {\n      var {\n        navigationState,\n        layout,\n        swipeDistanceThreshold = layout.width / 1.75\n      } = this.props;\n      var {\n        swipeVelocityThreshold = 0.15\n      } = this.props;\n      this.props.onSwipeEnd && this.props.onSwipeEnd();\n\n      if (Platform.OS === 'android') {\n        swipeVelocityThreshold /= 1000000;\n      }\n\n      var currentIndex = typeof this._pendingIndex === 'number' ? this._pendingIndex : this._currentIndex;\n      var nextIndex = currentIndex;\n\n      if (Math.abs(gestureState.dx) > Math.abs(gestureState.dy) && Math.abs(gestureState.vx) > Math.abs(gestureState.vy) && (Math.abs(gestureState.dx) > swipeDistanceThreshold || Math.abs(gestureState.vx) > swipeVelocityThreshold)) {\n        nextIndex = Math.round(Math.min(Math.max(0, currentIndex - gestureState.dx / Math.abs(gestureState.dx)), navigationState.routes.length - 1));\n        this._currentIndex = nextIndex;\n      }\n\n      if (!isFinite(nextIndex) || !this.props.canJumpToTab(this.props.navigationState.routes[nextIndex])) {\n        nextIndex = currentIndex;\n      }\n\n      this._transitionTo(nextIndex);\n    };\n\n    this._transitionTo = function (index) {\n      var animated = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var offset = -index * _this.props.layout.width;\n\n      if (_this.props.animationEnabled === false || animated === false) {\n        _this.props.panX.setValue(0);\n\n        _this.props.offsetX.setValue(offset);\n\n        return;\n      }\n\n      var {\n        timing\n      } = DefaultTransitionSpec,\n          transitionConfig = _objectWithoutProperties(DefaultTransitionSpec, [\"timing\"]);\n\n      Animated.parallel([timing(_this.props.panX, _objectSpread({}, transitionConfig, {\n        toValue: 0\n      })), timing(_this.props.offsetX, _objectSpread({}, transitionConfig, {\n        toValue: offset\n      }))]).start((_ref) => {\n        var {\n          finished\n        } = _ref;\n\n        if (finished) {\n          var route = _this.props.navigationState.routes[index];\n\n          _this.props.jumpTo(route.key);\n\n          _this.props.onAnimationEnd && _this.props.onAnimationEnd();\n          _this._pendingIndex = null;\n        }\n      });\n      _this._pendingIndex = index;\n    };\n\n    this._currentIndex = this.props.navigationState.index;\n  }\n\n  componentWillMount() {\n    this._panResponder = PanResponder.create({\n      onMoveShouldSetPanResponder: this._canMoveScreen,\n      onMoveShouldSetPanResponderCapture: this._canMoveScreen,\n      onPanResponderGrant: this._startGesture,\n      onPanResponderMove: this._respondToGesture,\n      onPanResponderTerminate: this._finishGesture,\n      onPanResponderRelease: this._finishGesture,\n      onPanResponderTerminationRequest: () => true\n    });\n  }\n\n  componentDidUpdate(prevProps) {\n    this._currentIndex = this.props.navigationState.index;\n\n    if (prevProps.navigationState.routes !== this.props.navigationState.routes || prevProps.layout.width !== this.props.layout.width) {\n      this._transitionTo(this.props.navigationState.index, false);\n    } else if (prevProps.navigationState.index !== this.props.navigationState.index) {\n      this._transitionTo(this.props.navigationState.index);\n    }\n  }\n\n  render() {\n    var {\n      panX,\n      offsetX,\n      navigationState,\n      layout,\n      children\n    } = this.props;\n    var {\n      width\n    } = layout;\n    var {\n      routes\n    } = navigationState;\n    var maxTranslate = width * (routes.length - 1);\n    var translateX = Animated.add(panX, offsetX).interpolate({\n      inputRange: [-maxTranslate, 0],\n      outputRange: [-maxTranslate, 0],\n      extrapolate: 'clamp'\n    });\n    return React.createElement(Animated.View, _extends({\n      style: [styles.sheet, width ? {\n        width: routes.length * width,\n        transform: [{\n          translateX\n        }]\n      } : null]\n    }, this._panResponder.panHandlers, {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 249\n      }\n    }), React.Children.map(children, (child, i) => React.createElement(View, {\n      key: navigationState.routes[i].key,\n      testID: navigationState.routes[i].testID,\n      style: width ? {\n        width\n      } : i === navigationState.index ? StyleSheet.absoluteFill : null,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 262\n      }\n    }, i === navigationState.index || width ? child : null)));\n  }\n\n}\nTabViewPagerPan.propTypes = _objectSpread({}, PagerRendererPropType, {\n  swipeDistanceThreshold: PropTypes.number,\n  swipeVelocityThreshold: PropTypes.number\n});\nTabViewPagerPan.defaultProps = {\n  canJumpToTab: () => true,\n  initialLayout: {\n    height: 0,\n    width: 0\n  }\n};\nvar styles = StyleSheet.create({\n  sheet: {\n    flex: 1,\n    flexDirection: 'row',\n    alignItems: 'stretch'\n  }\n});","map":{"version":3,"sources":["G:/projects/fortress/node_modules/react-native-tab-view/src/TabViewPagerPan.js"],"names":["React","PropTypes","PagerRendererPropType","DEAD_ZONE","DefaultTransitionSpec","timing","Animated","spring","tension","friction","TabViewPagerPan","Component","constructor","props","_isMovingHorizontally","evt","gestureState","Math","abs","dx","dy","vx","vy","_canMoveScreen","swipeEnabled","navigationState","routes","_currentIndex","length","_startGesture","onSwipeStart","panX","stopAnimation","_respondToGesture","index","setValue","_finishGesture","layout","swipeDistanceThreshold","width","swipeVelocityThreshold","onSwipeEnd","Platform","OS","currentIndex","_pendingIndex","nextIndex","round","min","max","isFinite","canJumpToTab","_transitionTo","animated","offset","animationEnabled","offsetX","transitionConfig","parallel","toValue","start","finished","route","jumpTo","key","onAnimationEnd","componentWillMount","_panResponder","PanResponder","create","onMoveShouldSetPanResponder","onMoveShouldSetPanResponderCapture","onPanResponderGrant","onPanResponderMove","onPanResponderTerminate","onPanResponderRelease","onPanResponderTerminationRequest","componentDidUpdate","prevProps","render","children","maxTranslate","translateX","add","interpolate","inputRange","outputRange","extrapolate","styles","sheet","transform","panHandlers","Children","map","child","i","testID","StyleSheet","absoluteFill","propTypes","number","defaultProps","initialLayout","height","flex","flexDirection","alignItems"],"mappings":"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","sourcesContent":["/* @flow */\n\nimport * as React from 'react';\nimport PropTypes from 'prop-types';\nimport {\n  Animated,\n  PanResponder,\n  StyleSheet,\n  View,\n  Platform,\n} from 'react-native';\nimport { PagerRendererPropType } from './TabViewPropTypes';\nimport type { PagerRendererProps } from './TabViewTypeDefinitions';\n\ntype GestureEvent = {\n  nativeEvent: {\n    changedTouches: Array<*>,\n    identifier: number,\n    locationX: number,\n    locationY: number,\n    pageX: number,\n    pageY: number,\n    target: number,\n    timestamp: number,\n    touches: Array<*>,\n  },\n};\n\ntype GestureState = {\n  stateID: number,\n  moveX: number,\n  moveY: number,\n  x0: number,\n  y0: number,\n  dx: number,\n  dy: number,\n  vx: number,\n  vy: number,\n  numberActiveTouches: number,\n};\n\ntype Props<T> = PagerRendererProps<T> & {\n  swipeDistanceThreshold?: number,\n  swipeVelocityThreshold?: number,\n  onSwipeStart?: () => mixed,\n  onSwipeEnd?: () => mixed,\n  onAnimationEnd?: () => mixed,\n};\n\nconst DEAD_ZONE = 12;\n\nconst DefaultTransitionSpec = {\n  timing: Animated.spring,\n  tension: 300,\n  friction: 35,\n};\n\nexport default class TabViewPagerPan<T: *> extends React.Component<Props<T>> {\n  static propTypes = {\n    ...PagerRendererPropType,\n    swipeDistanceThreshold: PropTypes.number,\n    swipeVelocityThreshold: PropTypes.number,\n  };\n\n  static defaultProps = {\n    canJumpToTab: () => true,\n    initialLayout: {\n      height: 0,\n      width: 0,\n    },\n  };\n\n  constructor(props: Props<T>) {\n    super(props);\n    this._currentIndex = this.props.navigationState.index;\n  }\n\n  componentWillMount() {\n    this._panResponder = PanResponder.create({\n      onMoveShouldSetPanResponder: this._canMoveScreen,\n      onMoveShouldSetPanResponderCapture: this._canMoveScreen,\n      onPanResponderGrant: this._startGesture,\n      onPanResponderMove: this._respondToGesture,\n      onPanResponderTerminate: this._finishGesture,\n      onPanResponderRelease: this._finishGesture,\n      onPanResponderTerminationRequest: () => true,\n    });\n  }\n\n  componentDidUpdate(prevProps: Props<T>) {\n    this._currentIndex = this.props.navigationState.index;\n\n    if (\n      prevProps.navigationState.routes !== this.props.navigationState.routes ||\n      prevProps.layout.width !== this.props.layout.width\n    ) {\n      this._transitionTo(this.props.navigationState.index, false);\n    } else if (\n      prevProps.navigationState.index !== this.props.navigationState.index\n    ) {\n      this._transitionTo(this.props.navigationState.index);\n    }\n  }\n\n  _currentIndex: number;\n\n  _isMovingHorizontally = (evt: GestureEvent, gestureState: GestureState) => {\n    return (\n      Math.abs(gestureState.dx) > Math.abs(gestureState.dy * 2) &&\n      Math.abs(gestureState.vx) > Math.abs(gestureState.vy * 2)\n    );\n  };\n\n  _canMoveScreen = (evt: GestureEvent, gestureState: GestureState) => {\n    if (this.props.swipeEnabled === false) {\n      return false;\n    }\n\n    const { navigationState: { routes } } = this.props;\n\n    return (\n      this._isMovingHorizontally(evt, gestureState) &&\n      ((gestureState.dx >= DEAD_ZONE && this._currentIndex > 0) ||\n        (gestureState.dx <= -DEAD_ZONE &&\n          this._currentIndex < routes.length - 1))\n    );\n  };\n\n  _startGesture = () => {\n    this.props.onSwipeStart && this.props.onSwipeStart();\n    this.props.panX.stopAnimation();\n  };\n\n  _respondToGesture = (evt: GestureEvent, gestureState: GestureState) => {\n    const { navigationState: { routes, index } } = this.props;\n\n    if (\n      // swiping left\n      (gestureState.dx > 0 && index <= 0) ||\n      // swiping right\n      (gestureState.dx < 0 && index >= routes.length - 1)\n    ) {\n      return;\n    }\n\n    this.props.panX.setValue(gestureState.dx);\n  };\n\n  _finishGesture = (evt: GestureEvent, gestureState: GestureState) => {\n    const {\n      navigationState,\n      layout,\n      swipeDistanceThreshold = layout.width / 1.75,\n    } = this.props;\n\n    let { swipeVelocityThreshold = 0.15 } = this.props;\n\n    this.props.onSwipeEnd && this.props.onSwipeEnd();\n\n    if (Platform.OS === 'android') {\n      // on Android, velocity is way lower due to timestamp being in nanosecond\n      // normalize it to have the same velocity on both iOS and Android\n      swipeVelocityThreshold /= 1000000;\n    }\n\n    const currentIndex =\n      typeof this._pendingIndex === 'number'\n        ? this._pendingIndex\n        : this._currentIndex;\n\n    let nextIndex = currentIndex;\n\n    if (\n      Math.abs(gestureState.dx) > Math.abs(gestureState.dy) &&\n      Math.abs(gestureState.vx) > Math.abs(gestureState.vy) &&\n      (Math.abs(gestureState.dx) > swipeDistanceThreshold ||\n        Math.abs(gestureState.vx) > swipeVelocityThreshold)\n    ) {\n      nextIndex = Math.round(\n        Math.min(\n          Math.max(\n            0,\n            currentIndex - gestureState.dx / Math.abs(gestureState.dx)\n          ),\n          navigationState.routes.length - 1\n        )\n      );\n\n      this._currentIndex = nextIndex;\n    }\n\n    if (\n      !isFinite(nextIndex) ||\n      !this.props.canJumpToTab(this.props.navigationState.routes[nextIndex])\n    ) {\n      nextIndex = currentIndex;\n    }\n\n    this._transitionTo(nextIndex);\n  };\n\n  _transitionTo = (index: number, animated: boolean = true) => {\n    const offset = -index * this.props.layout.width;\n\n    if (this.props.animationEnabled === false || animated === false) {\n      this.props.panX.setValue(0);\n      this.props.offsetX.setValue(offset);\n      return;\n    }\n\n    const { timing, ...transitionConfig } = DefaultTransitionSpec;\n\n    Animated.parallel([\n      timing(this.props.panX, {\n        ...transitionConfig,\n        toValue: 0,\n      }),\n      timing(this.props.offsetX, {\n        ...transitionConfig,\n        toValue: offset,\n      }),\n    ]).start(({ finished }) => {\n      if (finished) {\n        const route = this.props.navigationState.routes[index];\n        this.props.jumpTo(route.key);\n        this.props.onAnimationEnd && this.props.onAnimationEnd();\n        this._pendingIndex = null;\n      }\n    });\n\n    this._pendingIndex = index;\n  };\n\n  _panResponder: any;\n  _pendingIndex: ?number;\n\n  render() {\n    const { panX, offsetX, navigationState, layout, children } = this.props;\n    const { width } = layout;\n    const { routes } = navigationState;\n    const maxTranslate = width * (routes.length - 1);\n    const translateX = Animated.add(panX, offsetX).interpolate({\n      inputRange: [-maxTranslate, 0],\n      outputRange: [-maxTranslate, 0],\n      extrapolate: 'clamp',\n    });\n\n    return (\n      <Animated.View\n        style={[\n          styles.sheet,\n          width\n            ? {\n                width: routes.length * width,\n                transform: [{ translateX }],\n              }\n            : null,\n        ]}\n        {...this._panResponder.panHandlers}\n      >\n        {React.Children.map(children, (child, i) => (\n          <View\n            key={navigationState.routes[i].key}\n            testID={navigationState.routes[i].testID}\n            style={\n              width\n                ? { width }\n                : i === navigationState.index ? StyleSheet.absoluteFill : null\n            }\n          >\n            {i === navigationState.index || width ? child : null}\n          </View>\n        ))}\n      </Animated.View>\n    );\n  }\n}\n\nconst styles = StyleSheet.create({\n  sheet: {\n    flex: 1,\n    flexDirection: 'row',\n    alignItems: 'stretch',\n  },\n});\n"]},"metadata":{},"sourceType":"module"}