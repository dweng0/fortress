{"ast":null,"code":"var _jsxFileName = \"G:\\\\projects\\\\fortress\\\\node_modules\\\\react-native-animatable\\\\createAnimatableComponent.js\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport Animated from \"react-native-web/dist/exports/Animated\";\nimport Easing from \"react-native-web/dist/exports/Easing\";\nimport wrapStyleTransforms from \"./wrapStyleTransforms\";\nimport getStyleValues from \"./getStyleValues\";\nimport flattenStyle from \"./flattenStyle\";\nimport createAnimation from \"./createAnimation\";\nimport { getAnimationByName, getAnimationNames } from \"./registry\";\nimport EASING_FUNCTIONS from \"./easing\";\nvar INTERPOLATION_STYLE_PROPERTIES = ['rotate', 'rotateX', 'rotateY', 'rotateZ', 'skewX', 'skewY', 'transformMatrix', 'backgroundColor', 'borderColor', 'borderTopColor', 'borderRightColor', 'borderBottomColor', 'borderLeftColor', 'shadowColor', 'color', 'textDecorationColor', 'tintColor'];\nvar ZERO_CLAMPED_STYLE_PROPERTIES = ['width', 'height'];\n\nfunction omit(keys, source) {\n  var filtered = {};\n  Object.keys(source).forEach(key => {\n    if (keys.indexOf(key) === -1) {\n      filtered[key] = source[key];\n    }\n  });\n  return filtered;\n}\n\nfunction deepEquals(a, b) {\n  return a === b || JSON.stringify(a) === JSON.stringify(b);\n}\n\nfunction getAnimationTarget(iteration, direction) {\n  switch (direction) {\n    case 'reverse':\n      return 0;\n\n    case 'alternate':\n      return iteration % 2 ? 0 : 1;\n\n    case 'alternate-reverse':\n      return iteration % 2 ? 1 : 0;\n\n    case 'normal':\n    default:\n      return 1;\n  }\n}\n\nfunction getAnimationOrigin(iteration, direction) {\n  return getAnimationTarget(iteration, direction) ? 0 : 1;\n}\n\nfunction getCompiledAnimation(animation) {\n  if (typeof animation === 'string') {\n    var compiledAnimation = getAnimationByName(animation);\n\n    if (!compiledAnimation) {\n      throw new Error(\"No animation registred by the name of \".concat(animation));\n    }\n\n    return compiledAnimation;\n  }\n\n  return createAnimation(animation);\n}\n\nfunction makeInterpolatedStyle(compiledAnimation, animationValue) {\n  var style = {};\n  Object.keys(compiledAnimation).forEach(key => {\n    if (key === 'style') {\n      _extends(style, compiledAnimation.style);\n    } else if (key !== 'easing') {\n      style[key] = animationValue.interpolate(compiledAnimation[key]);\n    }\n  });\n  return wrapStyleTransforms(style);\n}\n\nfunction transitionToValue(property, transitionValue, toValue, duration, easing) {\n  var useNativeDriver = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  var delay = arguments.length > 6 ? arguments[6] : undefined;\n  var onTransitionBegin = arguments.length > 7 ? arguments[7] : undefined;\n  var onTransitionEnd = arguments.length > 8 ? arguments[8] : undefined;\n  var animation = duration || easing || delay ? Animated.timing(transitionValue, {\n    toValue,\n    delay,\n    duration: duration || 1000,\n    easing: typeof easing === 'function' ? easing : EASING_FUNCTIONS[easing || 'ease'],\n    useNativeDriver\n  }) : Animated.spring(transitionValue, {\n    toValue,\n    useNativeDriver\n  });\n  setTimeout(() => onTransitionBegin(property), delay);\n  animation.start(() => onTransitionEnd(property));\n}\n\nexport default function createAnimatableComponent(WrappedComponent) {\n  var _class, _temp;\n\n  var wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || 'Component';\n  var Animatable = Animated.createAnimatedComponent(WrappedComponent);\n  return _temp = _class = class AnimatableComponent extends Component {\n    constructor(props) {\n      super(props);\n      this.ref = null;\n\n      this.handleRef = ref => {\n        this.ref = ref;\n      };\n\n      var animationValue = new Animated.Value(getAnimationOrigin(0, this.props.direction));\n      var animationStyle = {};\n      var compiledAnimation = {};\n\n      if (props.animation) {\n        compiledAnimation = getCompiledAnimation(props.animation);\n        animationStyle = makeInterpolatedStyle(compiledAnimation, animationValue);\n      }\n\n      this.state = {\n        animationValue,\n        animationStyle,\n        compiledAnimation,\n        transitionStyle: {},\n        transitionValues: {},\n        currentTransitionValues: {}\n      };\n\n      if (props.transition) {\n        this.state = _objectSpread({}, this.state, {}, this.initializeTransitionState(props.transition));\n      }\n\n      this.delayTimer = null;\n      getAnimationNames().forEach(animationName => {\n        if (!(animationName in this)) {\n          this[animationName] = this.animate.bind(this, animationName);\n        }\n      });\n    }\n\n    initializeTransitionState(transitionKeys) {\n      var transitionValues = {};\n      var styleValues = {};\n      var currentTransitionValues = getStyleValues(transitionKeys, this.props.style);\n      Object.keys(currentTransitionValues).forEach(key => {\n        var value = currentTransitionValues[key];\n\n        if (INTERPOLATION_STYLE_PROPERTIES.indexOf(key) !== -1 || typeof value !== 'number') {\n          transitionValues[key] = new Animated.Value(0);\n          styleValues[key] = value;\n        } else {\n          var animationValue = new Animated.Value(value);\n          transitionValues[key] = animationValue;\n          styleValues[key] = animationValue;\n        }\n      });\n      return {\n        currentTransitionValues,\n        transitionStyle: styleValues,\n        transitionValues\n      };\n    }\n\n    getTransitionState(keys) {\n      var transitionKeys = typeof keys === 'string' ? [keys] : keys;\n      var {\n        transitionValues,\n        currentTransitionValues,\n        transitionStyle\n      } = this.state;\n      var missingKeys = transitionKeys.filter(key => !this.state.transitionValues[key]);\n\n      if (missingKeys.length) {\n        var transitionState = this.initializeTransitionState(missingKeys);\n        transitionValues = _objectSpread({}, transitionValues, {}, transitionState.transitionValues);\n        currentTransitionValues = _objectSpread({}, currentTransitionValues, {}, transitionState.currentTransitionValues);\n        transitionStyle = _objectSpread({}, transitionStyle, {}, transitionState.transitionStyle);\n      }\n\n      return {\n        transitionValues,\n        currentTransitionValues,\n        transitionStyle\n      };\n    }\n\n    setNativeProps(nativeProps) {\n      if (this.ref) {\n        this.ref.setNativeProps(nativeProps);\n      }\n    }\n\n    componentDidMount() {\n      var {\n        animation,\n        duration,\n        delay,\n        onAnimationBegin,\n        iterationDelay\n      } = this.props;\n\n      if (animation) {\n        var startAnimation = () => {\n          onAnimationBegin();\n          this.startAnimation(duration, 0, iterationDelay, endState => this.props.onAnimationEnd(endState));\n          this.delayTimer = null;\n        };\n\n        if (delay) {\n          this.delayTimer = setTimeout(startAnimation, delay);\n        } else {\n          startAnimation();\n        }\n      }\n    }\n\n    componentWillReceiveProps(props) {\n      var {\n        animation,\n        delay,\n        duration,\n        easing,\n        iterationDelay,\n        transition,\n        onAnimationBegin\n      } = props;\n\n      if (transition) {\n        var values = getStyleValues(transition, props.style);\n        this.transitionTo(values, duration, easing, delay);\n      } else if (!deepEquals(animation, this.props.animation)) {\n        if (animation) {\n          if (this.delayTimer) {\n            this.setAnimation(animation);\n          } else {\n            onAnimationBegin();\n            this.animate(animation, duration, iterationDelay).then(endState => this.props.onAnimationEnd(endState));\n          }\n        } else {\n          this.stopAnimation();\n        }\n      }\n    }\n\n    componentWillUnmount() {\n      if (this.delayTimer) {\n        clearTimeout(this.delayTimer);\n      }\n    }\n\n    setAnimation(animation, callback) {\n      var compiledAnimation = getCompiledAnimation(animation);\n      var animationStyle = makeInterpolatedStyle(compiledAnimation, this.state.animationValue);\n      this.setState({\n        animationStyle,\n        compiledAnimation\n      }, callback);\n    }\n\n    animate(animation, duration, iterationDelay) {\n      return new Promise(resolve => {\n        this.setAnimation(animation, () => {\n          this.startAnimation(duration, 0, iterationDelay, resolve);\n        });\n      });\n    }\n\n    stopAnimation() {\n      this.setState({\n        scheduledAnimation: false,\n        animationStyle: {}\n      });\n      this.state.animationValue.stopAnimation();\n\n      if (this.delayTimer) {\n        clearTimeout(this.delayTimer);\n        this.delayTimer = null;\n      }\n    }\n\n    startAnimation(duration, iteration, iterationDelay, callback) {\n      var {\n        animationValue,\n        compiledAnimation\n      } = this.state;\n      var {\n        direction,\n        iterationCount,\n        useNativeDriver\n      } = this.props;\n      var easing = this.props.easing || compiledAnimation.easing || 'ease';\n      var currentIteration = iteration || 0;\n      var fromValue = getAnimationOrigin(currentIteration, direction);\n      var toValue = getAnimationTarget(currentIteration, direction);\n      animationValue.setValue(fromValue);\n\n      if (typeof easing === 'string') {\n        easing = EASING_FUNCTIONS[easing];\n      }\n\n      var reversed = direction === 'reverse' || direction === 'alternate' && !toValue || direction === 'alternate-reverse' && !toValue;\n\n      if (reversed) {\n        easing = Easing.out(easing);\n      }\n\n      var config = {\n        toValue,\n        easing,\n        isInteraction: iterationCount <= 1,\n        duration: duration || this.props.duration || 1000,\n        useNativeDriver,\n        delay: iterationDelay || 0\n      };\n      Animated.timing(animationValue, config).start(endState => {\n        currentIteration += 1;\n\n        if (endState.finished && this.props.animation && (iterationCount === 'infinite' || currentIteration < iterationCount)) {\n          this.startAnimation(duration, currentIteration, iterationDelay, callback);\n        } else if (callback) {\n          callback(endState);\n        }\n      });\n    }\n\n    transition(fromValues, toValues, duration, easing) {\n      var fromValuesFlat = flattenStyle(fromValues);\n      var toValuesFlat = flattenStyle(toValues);\n      var transitionKeys = Object.keys(toValuesFlat);\n      var {\n        transitionValues,\n        currentTransitionValues,\n        transitionStyle\n      } = this.getTransitionState(transitionKeys);\n      transitionKeys.forEach(property => {\n        var fromValue = fromValuesFlat[property];\n        var toValue = toValuesFlat[property];\n        var transitionValue = transitionValues[property];\n\n        if (!transitionValue) {\n          transitionValue = new Animated.Value(0);\n        }\n\n        var needsInterpolation = INTERPOLATION_STYLE_PROPERTIES.indexOf(property) !== -1 || typeof value !== 'number';\n        var needsZeroClamping = ZERO_CLAMPED_STYLE_PROPERTIES.indexOf(property) !== -1;\n\n        if (needsInterpolation) {\n          transitionValue.setValue(0);\n          transitionStyle[property] = transitionValue.interpolate({\n            inputRange: [0, 1],\n            outputRange: [fromValue, toValue]\n          });\n          currentTransitionValues[property] = toValue;\n          toValuesFlat[property] = 1;\n        } else {\n          if (needsZeroClamping) {\n            transitionStyle[property] = transitionValue.interpolate({\n              inputRange: [0, 1],\n              outputRange: [0, 1],\n              extrapolateLeft: 'clamp'\n            });\n            currentTransitionValues[property] = toValue;\n          } else {\n            transitionStyle[property] = transitionValue;\n          }\n\n          transitionValue.setValue(fromValue);\n        }\n      });\n      this.setState({\n        transitionValues,\n        transitionStyle,\n        currentTransitionValues\n      }, () => {\n        this.transitionToValues(toValuesFlat, duration || this.props.duration, easing, this.props.delay);\n      });\n    }\n\n    transitionTo(toValues, duration, easing, delay) {\n      var {\n        currentTransitionValues\n      } = this.state;\n      var toValuesFlat = flattenStyle(toValues);\n      var transitions = {\n        from: {},\n        to: {}\n      };\n      Object.keys(toValuesFlat).forEach(property => {\n        var toValue = toValuesFlat[property];\n        var needsInterpolation = INTERPOLATION_STYLE_PROPERTIES.indexOf(property) !== -1 || typeof value !== 'number';\n        var needsZeroClamping = ZERO_CLAMPED_STYLE_PROPERTIES.indexOf(property) !== -1;\n        var transitionStyle = this.state.transitionStyle[property];\n        var transitionValue = this.state.transitionValues[property];\n\n        if (!needsInterpolation && !needsZeroClamping && transitionStyle && transitionStyle === transitionValue) {\n          transitionToValue(property, transitionValue, toValue, duration, easing, this.props.useNativeDriver, delay, prop => this.props.onTransitionBegin(prop), prop => this.props.onTransitionEnd(prop));\n        } else {\n          var currentTransitionValue = currentTransitionValues[property];\n\n          if (typeof currentTransitionValue === 'undefined' && this.props.style) {\n            var style = getStyleValues(property, this.props.style);\n            currentTransitionValue = style[property];\n          }\n\n          transitions.from[property] = currentTransitionValue;\n          transitions.to[property] = toValue;\n        }\n      });\n\n      if (Object.keys(transitions.from).length) {\n        this.transition(transitions.from, transitions.to, duration, easing);\n      }\n    }\n\n    transitionToValues(toValues, duration, easing, delay) {\n      Object.keys(toValues).forEach(property => {\n        var transitionValue = this.state.transitionValues[property];\n        var toValue = toValues[property];\n        transitionToValue(property, transitionValue, toValue, duration, easing, this.props.useNativeDriver, delay, prop => this.props.onTransitionBegin(prop), prop => this.props.onTransitionEnd(prop));\n      });\n    }\n\n    render() {\n      var {\n        style,\n        animation,\n        transition\n      } = this.props;\n\n      if (animation && transition) {\n        throw new Error('You cannot combine animation and transition props');\n      }\n\n      var restProps = omit(['animation', 'duration', 'direction', 'delay', 'easing', 'iterationCount', 'iterationDelay', 'onAnimationBegin', 'onAnimationEnd', 'onTransitionBegin', 'onTransitionEnd', 'style', 'transition', 'useNativeDriver'], this.props);\n      return React.createElement(Animatable, _extends({\n        ref: this.handleRef,\n        style: [style, this.state.animationStyle, wrapStyleTransforms(this.state.transitionStyle)]\n      }, restProps, {\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 572\n        }\n      }));\n    }\n\n  }, _class.displayName = \"withAnimatable(\".concat(wrappedComponentName, \")\"), _class.propTypes = {\n    animation: PropTypes.oneOfType([PropTypes.string, PropTypes.object]),\n    duration: PropTypes.number,\n    direction: PropTypes.oneOf(['normal', 'reverse', 'alternate', 'alternate-reverse']),\n    delay: PropTypes.number,\n    easing: PropTypes.oneOfType([PropTypes.oneOf(Object.keys(EASING_FUNCTIONS)), PropTypes.func]),\n\n    iterationCount(props, propName) {\n      var val = props[propName];\n\n      if (val !== 'infinite' && !(typeof val === 'number' && val >= 1)) {\n        return new Error('iterationCount must be a positive number or \"infinite\"');\n      }\n\n      return null;\n    },\n\n    iterationDelay: PropTypes.number,\n    onAnimationBegin: PropTypes.func,\n    onAnimationEnd: PropTypes.func,\n    onTransitionBegin: PropTypes.func,\n    onTransitionEnd: PropTypes.func,\n    style: PropTypes.oneOfType([PropTypes.number, PropTypes.array, PropTypes.object]),\n    transition: PropTypes.oneOfType([PropTypes.string, PropTypes.arrayOf(PropTypes.string)]),\n    useNativeDriver: PropTypes.bool\n  }, _class.defaultProps = {\n    animation: undefined,\n    delay: 0,\n    direction: 'normal',\n    duration: undefined,\n    easing: undefined,\n    iterationCount: 1,\n    iterationDelay: 0,\n\n    onAnimationBegin() {},\n\n    onAnimationEnd() {},\n\n    onTransitionBegin() {},\n\n    onTransitionEnd() {},\n\n    style: undefined,\n    transition: undefined,\n    useNativeDriver: false\n  }, _temp;\n}","map":{"version":3,"sources":["G:/projects/fortress/node_modules/react-native-animatable/createAnimatableComponent.js"],"names":["React","Component","PropTypes","wrapStyleTransforms","getStyleValues","flattenStyle","createAnimation","getAnimationByName","getAnimationNames","EASING_FUNCTIONS","INTERPOLATION_STYLE_PROPERTIES","ZERO_CLAMPED_STYLE_PROPERTIES","omit","keys","source","filtered","Object","forEach","key","indexOf","deepEquals","a","b","JSON","stringify","getAnimationTarget","iteration","direction","getAnimationOrigin","getCompiledAnimation","animation","compiledAnimation","Error","makeInterpolatedStyle","animationValue","style","interpolate","transitionToValue","property","transitionValue","toValue","duration","easing","useNativeDriver","delay","onTransitionBegin","onTransitionEnd","Animated","timing","spring","setTimeout","start","createAnimatableComponent","WrappedComponent","wrappedComponentName","displayName","name","Animatable","createAnimatedComponent","AnimatableComponent","constructor","props","ref","handleRef","Value","animationStyle","state","transitionStyle","transitionValues","currentTransitionValues","transition","initializeTransitionState","delayTimer","animationName","animate","bind","transitionKeys","styleValues","value","getTransitionState","missingKeys","filter","length","transitionState","setNativeProps","nativeProps","componentDidMount","onAnimationBegin","iterationDelay","startAnimation","endState","onAnimationEnd","componentWillReceiveProps","values","transitionTo","setAnimation","then","stopAnimation","componentWillUnmount","clearTimeout","callback","setState","Promise","resolve","scheduledAnimation","iterationCount","currentIteration","fromValue","setValue","reversed","Easing","out","config","isInteraction","finished","fromValues","toValues","fromValuesFlat","toValuesFlat","needsInterpolation","needsZeroClamping","inputRange","outputRange","extrapolateLeft","transitionToValues","transitions","from","to","prop","currentTransitionValue","render","restProps","propTypes","oneOfType","string","object","number","oneOf","func","propName","val","array","arrayOf","bool","defaultProps","undefined"],"mappings":"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","sourcesContent":["import React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport { Animated, Easing } from 'react-native';\nimport wrapStyleTransforms from './wrapStyleTransforms';\nimport getStyleValues from './getStyleValues';\nimport flattenStyle from './flattenStyle';\nimport createAnimation from './createAnimation';\nimport { getAnimationByName, getAnimationNames } from './registry';\nimport EASING_FUNCTIONS from './easing';\n\n// These styles are not number based and thus needs to be interpolated\nconst INTERPOLATION_STYLE_PROPERTIES = [\n  // Transform styles\n  'rotate',\n  'rotateX',\n  'rotateY',\n  'rotateZ',\n  'skewX',\n  'skewY',\n  'transformMatrix',\n  // View styles\n  'backgroundColor',\n  'borderColor',\n  'borderTopColor',\n  'borderRightColor',\n  'borderBottomColor',\n  'borderLeftColor',\n  'shadowColor',\n  // Text styles\n  'color',\n  'textDecorationColor',\n  // Image styles\n  'tintColor',\n];\n\nconst ZERO_CLAMPED_STYLE_PROPERTIES = ['width', 'height'];\n\n// Create a copy of `source` without `keys`\nfunction omit(keys, source) {\n  const filtered = {};\n  Object.keys(source).forEach(key => {\n    if (keys.indexOf(key) === -1) {\n      filtered[key] = source[key];\n    }\n  });\n  return filtered;\n}\n\n// Yes it's absurd, but actually fast\nfunction deepEquals(a, b) {\n  return a === b || JSON.stringify(a) === JSON.stringify(b);\n}\n\n// Determine to what value the animation should tween to\nfunction getAnimationTarget(iteration, direction) {\n  switch (direction) {\n    case 'reverse':\n      return 0;\n    case 'alternate':\n      return iteration % 2 ? 0 : 1;\n    case 'alternate-reverse':\n      return iteration % 2 ? 1 : 0;\n    case 'normal':\n    default:\n      return 1;\n  }\n}\n\n// Like getAnimationTarget but opposite\nfunction getAnimationOrigin(iteration, direction) {\n  return getAnimationTarget(iteration, direction) ? 0 : 1;\n}\n\nfunction getCompiledAnimation(animation) {\n  if (typeof animation === 'string') {\n    const compiledAnimation = getAnimationByName(animation);\n    if (!compiledAnimation) {\n      throw new Error(`No animation registred by the name of ${animation}`);\n    }\n    return compiledAnimation;\n  }\n  return createAnimation(animation);\n}\n\nfunction makeInterpolatedStyle(compiledAnimation, animationValue) {\n  const style = {};\n  Object.keys(compiledAnimation).forEach(key => {\n    if (key === 'style') {\n      Object.assign(style, compiledAnimation.style);\n    } else if (key !== 'easing') {\n      style[key] = animationValue.interpolate(compiledAnimation[key]);\n    }\n  });\n  return wrapStyleTransforms(style);\n}\n\nfunction transitionToValue(\n  property,\n  transitionValue,\n  toValue,\n  duration,\n  easing,\n  useNativeDriver = false,\n  delay,\n  onTransitionBegin,\n  onTransitionEnd,\n) {\n  const animation =\n    duration || easing || delay\n      ? Animated.timing(transitionValue, {\n          toValue,\n          delay,\n          duration: duration || 1000,\n          easing:\n            typeof easing === 'function'\n              ? easing\n              : EASING_FUNCTIONS[easing || 'ease'],\n          useNativeDriver,\n        })\n      : Animated.spring(transitionValue, { toValue, useNativeDriver });\n  setTimeout(() => onTransitionBegin(property), delay);\n  animation.start(() => onTransitionEnd(property));\n}\n\n// Make (almost) any component animatable, similar to Animated.createAnimatedComponent\nexport default function createAnimatableComponent(WrappedComponent) {\n  const wrappedComponentName =\n    WrappedComponent.displayName || WrappedComponent.name || 'Component';\n\n  const Animatable = Animated.createAnimatedComponent(WrappedComponent);\n\n  return class AnimatableComponent extends Component {\n    static displayName = `withAnimatable(${wrappedComponentName})`;\n\n    static propTypes = {\n      animation: PropTypes.oneOfType([PropTypes.string, PropTypes.object]),\n      duration: PropTypes.number,\n      direction: PropTypes.oneOf([\n        'normal',\n        'reverse',\n        'alternate',\n        'alternate-reverse',\n      ]),\n      delay: PropTypes.number,\n      easing: PropTypes.oneOfType([\n        PropTypes.oneOf(Object.keys(EASING_FUNCTIONS)),\n        PropTypes.func,\n      ]),\n      iterationCount(props, propName) {\n        const val = props[propName];\n        if (val !== 'infinite' && !(typeof val === 'number' && val >= 1)) {\n          return new Error(\n            'iterationCount must be a positive number or \"infinite\"',\n          );\n        }\n        return null;\n      },\n      iterationDelay: PropTypes.number,\n      onAnimationBegin: PropTypes.func,\n      onAnimationEnd: PropTypes.func,\n      onTransitionBegin: PropTypes.func,\n      onTransitionEnd: PropTypes.func,\n      style: PropTypes.oneOfType([\n        PropTypes.number,\n        PropTypes.array,\n        PropTypes.object,\n      ]),\n      transition: PropTypes.oneOfType([\n        PropTypes.string,\n        PropTypes.arrayOf(PropTypes.string),\n      ]),\n      useNativeDriver: PropTypes.bool,\n    };\n\n    static defaultProps = {\n      animation: undefined,\n      delay: 0,\n      direction: 'normal',\n      duration: undefined,\n      easing: undefined,\n      iterationCount: 1,\n      iterationDelay: 0,\n      onAnimationBegin() {},\n      onAnimationEnd() {},\n      onTransitionBegin() {},\n      onTransitionEnd() {},\n      style: undefined,\n      transition: undefined,\n      useNativeDriver: false,\n    };\n\n    constructor(props) {\n      super(props);\n\n      const animationValue = new Animated.Value(\n        getAnimationOrigin(0, this.props.direction),\n      );\n      let animationStyle = {};\n      let compiledAnimation = {};\n      if (props.animation) {\n        compiledAnimation = getCompiledAnimation(props.animation);\n        animationStyle = makeInterpolatedStyle(\n          compiledAnimation,\n          animationValue,\n        );\n      }\n      this.state = {\n        animationValue,\n        animationStyle,\n        compiledAnimation,\n        transitionStyle: {},\n        transitionValues: {},\n        currentTransitionValues: {},\n      };\n\n      if (props.transition) {\n        this.state = {\n          ...this.state,\n          ...this.initializeTransitionState(props.transition),\n        };\n      }\n      this.delayTimer = null;\n\n      // Alias registered animations for backwards compatibility\n      getAnimationNames().forEach(animationName => {\n        if (!(animationName in this)) {\n          this[animationName] = this.animate.bind(this, animationName);\n        }\n      });\n    }\n\n    initializeTransitionState(transitionKeys) {\n      const transitionValues = {};\n      const styleValues = {};\n\n      const currentTransitionValues = getStyleValues(\n        transitionKeys,\n        this.props.style,\n      );\n      Object.keys(currentTransitionValues).forEach(key => {\n        const value = currentTransitionValues[key];\n        if (INTERPOLATION_STYLE_PROPERTIES.indexOf(key) !== -1 || typeof(value) !== 'number') {\n          transitionValues[key] = new Animated.Value(0);\n          styleValues[key] = value;\n        } else {\n          const animationValue = new Animated.Value(value);\n          transitionValues[key] = animationValue;\n          styleValues[key] = animationValue;\n        }\n      });\n\n      return {\n        currentTransitionValues,\n        transitionStyle: styleValues,\n        transitionValues,\n      };\n    }\n\n    getTransitionState(keys) {\n      const transitionKeys = typeof keys === 'string' ? [keys] : keys;\n      let {\n        transitionValues,\n        currentTransitionValues,\n        transitionStyle,\n      } = this.state;\n      const missingKeys = transitionKeys.filter(\n        key => !this.state.transitionValues[key],\n      );\n      if (missingKeys.length) {\n        const transitionState = this.initializeTransitionState(missingKeys);\n        transitionValues = {\n          ...transitionValues,\n          ...transitionState.transitionValues,\n        };\n        currentTransitionValues = {\n          ...currentTransitionValues,\n          ...transitionState.currentTransitionValues,\n        };\n        transitionStyle = {\n          ...transitionStyle,\n          ...transitionState.transitionStyle,\n        };\n      }\n      return { transitionValues, currentTransitionValues, transitionStyle };\n    }\n\n    ref = null;\n    handleRef = ref => {\n      this.ref = ref;\n    };\n\n    setNativeProps(nativeProps) {\n      if (this.ref) {\n        this.ref.setNativeProps(nativeProps);\n      }\n    }\n\n    componentDidMount() {\n      const {\n        animation,\n        duration,\n        delay,\n        onAnimationBegin,\n        iterationDelay,\n      } = this.props;\n      if (animation) {\n        const startAnimation = () => {\n          onAnimationBegin();\n          this.startAnimation(duration, 0, iterationDelay, endState =>\n            this.props.onAnimationEnd(endState),\n          );\n          this.delayTimer = null;\n        };\n        if (delay) {\n          this.delayTimer = setTimeout(startAnimation, delay);\n        } else {\n          startAnimation();\n        }\n      }\n    }\n\n    componentWillReceiveProps(props) {\n      const {\n        animation,\n        delay,\n        duration,\n        easing,\n        iterationDelay,\n        transition,\n        onAnimationBegin,\n      } = props;\n\n      if (transition) {\n        const values = getStyleValues(transition, props.style);\n        this.transitionTo(values, duration, easing, delay);\n      } else if (!deepEquals(animation, this.props.animation)) {\n        if (animation) {\n          if (this.delayTimer) {\n            this.setAnimation(animation);\n          } else {\n            onAnimationBegin();\n            this.animate(animation, duration, iterationDelay).then(endState =>\n              this.props.onAnimationEnd(endState),\n            );\n          }\n        } else {\n          this.stopAnimation();\n        }\n      }\n    }\n\n    componentWillUnmount() {\n      if (this.delayTimer) {\n        clearTimeout(this.delayTimer);\n      }\n    }\n\n    setAnimation(animation, callback) {\n      const compiledAnimation = getCompiledAnimation(animation);\n      const animationStyle = makeInterpolatedStyle(\n        compiledAnimation,\n        this.state.animationValue,\n      );\n      this.setState({ animationStyle, compiledAnimation }, callback);\n    }\n\n    animate(animation, duration, iterationDelay) {\n      return new Promise(resolve => {\n        this.setAnimation(animation, () => {\n          this.startAnimation(duration, 0, iterationDelay, resolve);\n        });\n      });\n    }\n\n    stopAnimation() {\n      this.setState({\n        scheduledAnimation: false,\n        animationStyle: {},\n      });\n      this.state.animationValue.stopAnimation();\n      if (this.delayTimer) {\n        clearTimeout(this.delayTimer);\n        this.delayTimer = null;\n      }\n    }\n\n    startAnimation(duration, iteration, iterationDelay, callback) {\n      const { animationValue, compiledAnimation } = this.state;\n      const { direction, iterationCount, useNativeDriver } = this.props;\n      let easing = this.props.easing || compiledAnimation.easing || 'ease';\n      let currentIteration = iteration || 0;\n      const fromValue = getAnimationOrigin(currentIteration, direction);\n      const toValue = getAnimationTarget(currentIteration, direction);\n      animationValue.setValue(fromValue);\n\n      if (typeof easing === 'string') {\n        easing = EASING_FUNCTIONS[easing];\n      }\n      // Reverse easing if on the way back\n      const reversed =\n        direction === 'reverse' ||\n        (direction === 'alternate' && !toValue) ||\n        (direction === 'alternate-reverse' && !toValue);\n      if (reversed) {\n        easing = Easing.out(easing);\n      }\n      const config = {\n        toValue,\n        easing,\n        isInteraction: iterationCount <= 1,\n        duration: duration || this.props.duration || 1000,\n        useNativeDriver,\n        delay: iterationDelay || 0,\n      };\n\n      Animated.timing(animationValue, config).start(endState => {\n        currentIteration += 1;\n        if (\n          endState.finished &&\n          this.props.animation &&\n          (iterationCount === 'infinite' || currentIteration < iterationCount)\n        ) {\n          this.startAnimation(\n            duration,\n            currentIteration,\n            iterationDelay,\n            callback,\n          );\n        } else if (callback) {\n          callback(endState);\n        }\n      });\n    }\n\n    transition(fromValues, toValues, duration, easing) {\n      const fromValuesFlat = flattenStyle(fromValues);\n      const toValuesFlat = flattenStyle(toValues);\n      const transitionKeys = Object.keys(toValuesFlat);\n      const {\n        transitionValues,\n        currentTransitionValues,\n        transitionStyle,\n      } = this.getTransitionState(transitionKeys);\n\n      transitionKeys.forEach(property => {\n        const fromValue = fromValuesFlat[property];\n        const toValue = toValuesFlat[property];\n        let transitionValue = transitionValues[property];\n        if (!transitionValue) {\n          transitionValue = new Animated.Value(0);\n        }\n        const needsInterpolation =\n          INTERPOLATION_STYLE_PROPERTIES.indexOf(property) !== -1 || typeof(value) !== 'number';\n        const needsZeroClamping =\n          ZERO_CLAMPED_STYLE_PROPERTIES.indexOf(property) !== -1;\n        if (needsInterpolation) {\n          transitionValue.setValue(0);\n          transitionStyle[property] = transitionValue.interpolate({\n            inputRange: [0, 1],\n            outputRange: [fromValue, toValue],\n          });\n          currentTransitionValues[property] = toValue;\n          toValuesFlat[property] = 1;\n        } else {\n          if (needsZeroClamping) {\n            transitionStyle[property] = transitionValue.interpolate({\n              inputRange: [0, 1],\n              outputRange: [0, 1],\n              extrapolateLeft: 'clamp',\n            });\n            currentTransitionValues[property] = toValue;\n          } else {\n            transitionStyle[property] = transitionValue;\n          }\n          transitionValue.setValue(fromValue);\n        }\n      });\n      this.setState(\n        { transitionValues, transitionStyle, currentTransitionValues },\n        () => {\n          this.transitionToValues(\n            toValuesFlat,\n            duration || this.props.duration,\n            easing,\n            this.props.delay,\n          );\n        },\n      );\n    }\n\n    transitionTo(toValues, duration, easing, delay) {\n      const { currentTransitionValues } = this.state;\n      const toValuesFlat = flattenStyle(toValues);\n      const transitions = {\n        from: {},\n        to: {},\n      };\n\n      Object.keys(toValuesFlat).forEach(property => {\n        const toValue = toValuesFlat[property];\n        const needsInterpolation =\n          INTERPOLATION_STYLE_PROPERTIES.indexOf(property) !== -1 || typeof(value) !== 'number';\n        const needsZeroClamping =\n          ZERO_CLAMPED_STYLE_PROPERTIES.indexOf(property) !== -1;\n        const transitionStyle = this.state.transitionStyle[property];\n        const transitionValue = this.state.transitionValues[property];\n        if (\n          !needsInterpolation &&\n          !needsZeroClamping &&\n          transitionStyle &&\n          transitionStyle === transitionValue\n        ) {\n          transitionToValue(\n            property,\n            transitionValue,\n            toValue,\n            duration,\n            easing,\n            this.props.useNativeDriver,\n            delay,\n            prop => this.props.onTransitionBegin(prop),\n            prop => this.props.onTransitionEnd(prop),\n          );\n        } else {\n          let currentTransitionValue = currentTransitionValues[property];\n          if (\n            typeof currentTransitionValue === 'undefined' &&\n            this.props.style\n          ) {\n            const style = getStyleValues(property, this.props.style);\n            currentTransitionValue = style[property];\n          }\n          transitions.from[property] = currentTransitionValue;\n          transitions.to[property] = toValue;\n        }\n      });\n\n      if (Object.keys(transitions.from).length) {\n        this.transition(transitions.from, transitions.to, duration, easing);\n      }\n    }\n\n    transitionToValues(toValues, duration, easing, delay) {\n      Object.keys(toValues).forEach(property => {\n        const transitionValue = this.state.transitionValues[property];\n        const toValue = toValues[property];\n        transitionToValue(\n          property,\n          transitionValue,\n          toValue,\n          duration,\n          easing,\n          this.props.useNativeDriver,\n          delay,\n          prop => this.props.onTransitionBegin(prop),\n          prop => this.props.onTransitionEnd(prop),\n        );\n      });\n    }\n\n    render() {\n      const { style, animation, transition } = this.props;\n      if (animation && transition) {\n        throw new Error('You cannot combine animation and transition props');\n      }\n      const restProps = omit(\n        ['animation', 'duration', 'direction', 'delay', 'easing', 'iterationCount', 'iterationDelay', 'onAnimationBegin', 'onAnimationEnd', 'onTransitionBegin', 'onTransitionEnd', 'style', 'transition', 'useNativeDriver'],\n        this.props,\n      );\n\n      return (\n        <Animatable\n          ref={this.handleRef}\n          style={[\n            style,\n            this.state.animationStyle,\n            wrapStyleTransforms(this.state.transitionStyle),\n          ]}\n          {...restProps}\n        />\n      );\n    }\n  };\n}\n"]},"metadata":{},"sourceType":"module"}